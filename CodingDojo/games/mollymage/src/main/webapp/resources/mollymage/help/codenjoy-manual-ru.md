<!-- Code generated by ManualGeneratorRunner.java
  !!!DO NOT EDIT!!! -->
<meta charset="UTF-8">

## Вступление

Игровой demo-сервер доступен так же в интернете 24/7 в целях
ознакомления [http://codenjoy.com/codenjoy-contest](http://codenjoy.com/codenjoy-contest).

Игра с открытым исходным кодом. Для реализации своей игры, исправления
ошибок в текущей и внесения других правок необходимо для начала
[форкнуть проект](https://github.com/codenjoyme/codenjoy.git).
В корне репозитория есть описание в файле Readme.md - там описано, что делать дальше.

По возникающим вопросам, пиши в [skype alexander.baglay](skype:alexander.baglay)
или на почту [apofig@gmail.com](mailto:apofig@gmail.com).


## В чем суть игры?

Будь внимателен: во время игры тебе стоит сосредоточиться на реализации логики
передвижения и активности героя. Остальное - подключение по websocket, некоторое
API для парсинга борды - уже реализовано для тебя.

Надо написать своего бота для героя, который обыграет других
ботов по очкам. Все играют на одном поле. Герой может передвигаться
по свободным ячейкам во все четыре стороны.

Герой может также поставить зелье. Зелье взорвется через 5 тиков
(секунд). Ядовитые газы от зелья могут зацепить обитателей поля.
Все, кто был задет - исчезает. С помощью зелья можно открывать сундуки.
Пострадать можно и на своем, и на чужом зелье. 

На своем пути герой может повстречать призрака - призрачная 
субстанция, уничтожающая на своем пути всех героев. 

Каждый разрушенный объект на поле (герой, призрак, сундуки)
тут же восстанавливается в другом месте. Если пострадал герой,
ему зачисляются штрафные очки -50[(?)](#ask). 

Герой, от зелья которого были открыты сундуки или уничтожены 
другие участники на карте получит
бонусные очки: за открытый сундук +10[(?)](#ask), 
за призрака +100[(?)](#ask), за
другого героя +1000[(?)](#ask). 

Очки суммируются. Побеждает игрок с большим числом очков (до условленного
времени).

[(?)](#ask)Точное количество очков за любое действие, а так же другие
настройки на данный момент игры уточни у Сенсея.

## Подключение к серверу

Итак, игрок [регистрируется на сервере](../../../register?gameName=mollymage),
указывая свой email.

Далее необходимо подключиться из кода к серверу через websocket. 
[Эта подборка](https://github.com/codenjoyme/codenjoy-clients.git) 
клиентов для разных языков программирования тебе поможет в твоей игре. 
Как запустить клиент смотри в корне проекта в файле README.md.

Если ты не можешь найти свой язык - придется написать свой клиент
(а после пошарить с нами на почту [apofig@gmail.com](mailto:apofig@gmail.com))

Адрес для подключения к игре на сервере выглядит так (ты можешь скопировать его 
из игровой комнаты):

`https://[server]/codenjoy-contest/board/player/[user]?code=[code]`

Тут `[server]` - домен или ip-адрес игрового сервера, `[user]` - id игрока, 
a `[code]` - твой security token. Убедись что код хранится в тайне, 
иначе любой участник сможет играть от твоего имени.

В коде твоего клиента тебе нужно найти похожую строчку и заменить её твоим URL -
тем самым, ты задаёшь логин/пароль для доступа к серверу.
Затем запусти твой клиент и убедись, что сервер получает команды твоего клиента.
После этого можно приступать к работе над логикой бота.

## Формат сообщений

После подключения клиент будет регулярно (каждую секунду) получать строку
символов с закодированным состоянием поля. Формат таков:

`^board=(.*)$`

C помощью этого regexp можно выкусить строку доски.

## Пример поля

Вот пример строки от сервера:

<pre>board=☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼ #   # #  #♥#  #  #  &        #☼☼♥☼♥☼♥☼#☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼#☼#☼♥☼#☼#☼☼#♥♥  ♥#   # #♥   # ♥#          ☼☼ ☼ ☼#☼ ☼♥☼ ☼ ☼#☼ ☼ ☼ ☼ ☼&☼ ☼ ☼ ☼☼     ♥          # #            ☼☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼♥☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼#       # #       ☺& 2  #  #  #☼☼#☼♥☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼☼#  # ♥#               # ♥   #  ☼☼ ☼ ☼#☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼☼   #♥ #      #                 ☼☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼☼     ## #     #   # #   ♥      ☼☼ ☼ ☼♥☼ ☼ ☼#☼ ☼#☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼☼       #♥       #      ## # ###☼☼ ☼ ☼ ☼#☼ ☼ ☼#☼ ☼ ☼#☼#☼&☼ ☼ ☼ ☼ ☼☼       #       #    ♣# #     ♥ ☼☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼☼        ## ## ♥             # #☼☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼                   &    ###  ##☼☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼☼                   ♥ ##        ☼☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼♥☼#☼ ☼ ☼ ☼☼     ##         &#         #   ☼☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼☼   #   #         #     # &     ☼☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼#☼ ☼☼  #                    ##   &  ☼☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼☼ #    # &        #       #     ☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

Длинна строки равна площади поля `N*N`. Если вставить символ
переноса строки каждые `N=sqrt(length(string))` символов, то
получится читабельное изображение поля:

<pre>☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼
☼ #   # #  #♥#  #  #  &        #☼
☼♥☼♥☼♥☼#☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼#☼#☼♥☼#☼#☼
☼#♥♥  ♥#   # #♥   # ♥#          ☼
☼ ☼ ☼#☼ ☼♥☼ ☼ ☼#☼ ☼ ☼ ☼ ☼&☼ ☼ ☼ ☼
☼     ♥          # #            ☼
☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼♥☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼#       # #       ☺& 2  #  #  #☼
☼#☼♥☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼
☼#  # ♥#               # ♥   #  ☼
☼ ☼ ☼#☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼
☼   #♥ #      #                 ☼
☼ ☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼
☼     ## #     #   # #   ♥      ☼
☼ ☼ ☼♥☼ ☼ ☼#☼ ☼#☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼
☼       #♥       #      ## # ###☼
☼ ☼ ☼ ☼#☼ ☼ ☼#☼ ☼ ☼#☼#☼&☼ ☼ ☼ ☼ ☼
☼       #       #    ♣# #     ♥ ☼
☼ ☼ ☼ ☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼
☼        ## ## ♥             # #☼
☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼                   &    ###  ##☼
☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼
☼                   ♥ ##        ☼
☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼♥☼#☼ ☼ ☼ ☼
☼     ##         &#         #   ☼
☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼
☼   #   #         #     # &     ☼
☼♥☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼ ☼#☼#☼ ☼
☼  #                    ##   &  ☼
☼ ☼ ☼ ☼ ☼ ☼#☼ ☼ ☼ ☼ ☼ ☼ ☼#☼ ☼#☼ ☼
☼ #    # &        #       #     ☼
☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼☼</pre>

Первый символ строки соответствует ячейке расположенной в 
левом верхнем углу и имеет координату `[0, 32]`.
Координата `[0, 0]` соответствует левому нижнему углу.
В этом примере — позиция героя (символ `☺`) — `[19, 25]`. 

Как это поле выглядит в реале:

<img src="/codenjoy-contest/resources/mollymage/img/board/large.png" style="height:auto;" />

<meta charset="UTF-8">

## Symbol breakdown
| Sprite | Code | Description |
| -------- | -------- | -------- |
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_timer_5.png" style="height:auto;" /> | `POTION_TIMER_5('5')` | После того как герой поставит зелье таймер включится (всего 5 тиков). | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_timer_4.png" style="height:auto;" /> | `POTION_TIMER_4('4')` | Это зелье взорвется после 4 тика. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_timer_3.png" style="height:auto;" /> | `POTION_TIMER_3('3')` | Это после 3... | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_timer_2.png" style="height:auto;" /> | `POTION_TIMER_2('2')` | Два.. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_timer_1.png" style="height:auto;" /> | `POTION_TIMER_1('1')` | Один. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/blast.png" style="height:auto;" /> | `BLAST('҉')` | Пуф! Это то, как зелье взрывается. При этом всех, кого можно уничтожить - будут уничтожены, закрытые сундуки - откроются. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/wall.png" style="height:auto;" /> | `WALL('☼')` | Неразрушаемые стены - им пары зелья не страшны. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/treasure_box.png" style="height:auto;" /> | `TREASURE_BOX('#')` | А это сундук с сокровищами, может быть открыт во время взрыва зелья. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/treasure_box_opening.png" style="height:auto;" /> | `TREASURE_BOX_OPENING('H')` | Это как открытый сундук выглядит, она пропадет в следующую секунду. Если это твоих рук дело - ты получишь бонусные очки. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/ghost.png" style="height:auto;" /> | `GHOST('&')` | Этот малый бегает по полю в произвольном порядке если он дотронется до героя - тот умрет его можно уничтожить с помощью зелья заработав бонусные очки. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/ghost_dead.png" style="height:auto;" /> | `GHOST_DEAD('x')` | Это уничтоженный призрак. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_blast_radius_increase.png" style="height:auto;" /> | `POTION_BLAST_RADIUS_INCREASE('+')` | Увеличивает радиус[(?)](#ask) распространения ядовитых паров. Действует только для вновь установленных зелий. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_count_increase.png" style="height:auto;" /> | `POTION_COUNT_INCREASE('c')` | Увеличивает количество[(?)](#ask) доступных игроку зелий. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_remote_control.png" style="height:auto;" /> | `POTION_REMOTE_CONTROL('r')` | Дистанционный детонатор. Срабатывает при повторном действии `ACT` команды. Количество детонаторов задается настройками[(?)](#ask). | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_immune.png" style="height:auto;" /> | `POTION_IMMUNE('i')` | Дает иммунитет от ядовитых паров на время[(?)](#ask). | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/poison_thrower.png" style="height:auto;" /> | `POISON_THROWER('T')` | Ядомет. Позволяет герою стрелять ядом. Радиус действия такой же как и у зелья. Активируется командой `АСТ(1),<DIRECTION>` (например: `RIGHT,ACT(1)`), работает параллельно с установкой зелий. После применения необходима "перезарядка". Действие временное[(?)](#ask). | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/potion_exploder.png" style="height:auto;" /> | `POTION_EXPLODER('A')` | Детонатор всех зелий на поле. Позволяет игроку взорвать все существующие зелья на поле независимо от их владельца и типа. Активируется командой `АСТ(2)`. Действие временное[(?)](#ask). | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/none.png" style="height:auto;" /> | `NONE(' ')` | Cвободная ячейка, куда ты можешь направить героя. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/hero.png" style="height:auto;" /> | `HERO('☺')` | Это то, как твой герой выглядит. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/hero_potion.png" style="height:auto;" /> | `HERO_POTION('☻')` | Твой герой варит зелье. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/hero_dead.png" style="height:auto;" /> | `HERO_DEAD('Ѡ')` | Ойкс! Твой герой умер. Не волнуйся, он появится через секунду где-нибудь на поле, но вполне вероятно за это ты получишь штрафные очки. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/other_hero.png" style="height:auto;" /> | `OTHER_HERO('♥')` | Это то, как другой игрок выглядит. В зависимости от режима игры: командный или все против всех - это либо либо напарник либо противник соответственно. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/other_hero_potion.png" style="height:auto;" /> | `OTHER_HERO_POTION('♠')` | Другой герой под которым варится зелье. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/other_hero_dead.png" style="height:auto;" /> | `OTHER_HERO_DEAD('♣')` | Другой герой погиб (он пропадет в следующем тике). Если это твоих рук дело - ты получишь бонусные очки. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/enemy_hero.png" style="height:auto;" /> | `ENEMY_HERO('ö')` | Герой противник. Актуально для командной игры. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/enemy_hero_potion.png" style="height:auto;" /> | `ENEMY_HERO_POTION('Ö')` | Герой-противник под которым варится зелье. | 
|<img src="/codenjoy-contest/resources/mollymage/sprite/enemy_hero_dead.png" style="height:auto;" /> | `ENEMY_HERO_DEAD('ø')` | Герой-противник уничтожен. Если это твоя заслуга - ты получишь бонусные очки. | 


## Как играть?

Игра пошаговая, каждую секунду сервер посылает твоему клиенту
состояние обновленного поля на текущий момент и ожидает ответа
команды герою. За следующую секунду игрок должен успеть дать
команду герою. Если не успел — герой стоит на месте.

Твоя цель заставить героя двигаться в соответствии с задуманным тобой алгоритмом.
Герой на поле должен уметь зарабатывать так много очков, как только сможет.
Основная цель игры - обыграть по очкам всех соперников.

## Команды управления

Команд несколько: 

* `UP`, `DOWN`, `LEFT`, `RIGHT` – приводят к движению героя в
  заданном направлении на 1 клетку.
* `ACT` - оставить зелье на месте героя. Также, если у героя есть перк 
  `POTION_REMOTE_CONTROL` - он может взорвать свое зелье дистанционно 
  по второй команде `ACT` тогда, когда ему это потребуется.
* `АСТ,<DIRECTION>`,`<DIRECTION>,АСТ` - команды движения можно
  комбинировать с командой `ACT`, разделяя их через запятую. Порядок 
  `LEFT,ACT` или `ACT,LEFT` - имеет значение, либо двигаемся 
  влево и там ставим зелье, либо ставим зелье, а затем ходим
  влево. Если игрок будет использовать только одну команду `ACT`, то зелье
  установится под героем без его перемещения на поле. 
* `АСТ(1),<DIRECTION>` - Используется только при наличии перка 
  `POISON_THROWER`. Позволяет бросить в сторону противника 
  пары яда. Используется в паре с командой смены направления 
  движения, разделенные через запятую. Порядок
  `LEFT,ACT(1)` или `ACT(1),LEFT` - значения не имеет. Без указания 
  направления ничего не произойдет, герой останется стоять на месте.
* `ACT(2)` - работает только с перком `POTION_EXPLODER`. После вызова 
  команды все зелья на поле взрываются одновременно. Действует на все 
  зелья (собственные, командные, вражеские, дистанционные).
  Может использоваться как одна команда и может сочетаться с направлением.
  Пример: `RIGHT,ACT(2)` - в этом случае Молли попытается двигаться 
  вправо, после чего все зелья на поле взорвутся.

## Перки

* `POTION_BLAST_RADIUS_INCREASE` - увеличивает радиус взрыва зелья.
  `{значение: +2, время действия: 30}`[(?)](#ask)
* `POTION_COUNT_INCREASE` - временно увеличивает количество устанавливаемых зелий.
  `{количество: +4, время действия: 30}`[(?)](#ask)
* `POTION_REMOTE_CONTROL` - несколько следующих зейли будут управляемым таймером.
  Активация командой `ACT`. `{значение:  3}`[(?)](#ask)
* `POTION_IMMUNE` - дает временную неуязвимость к взрыву.
  `{время действия: 30}`[(?)](#ask)
* `POISON_THROWER`  герой может стрелять облаком яда.
  Используется командой: `ACT(1),<DIRECTION>`. `{время действия: 30}`[(?)](#ask)
* `POTION_EXPLODER`  Герой может взровать одновременно все зелья на поле.
  Используется командой: `ACT(2)`. `{number of  use: +1, время действия: 30}`[(?)](#ask)

## Настройки

Параметры будут меняться[(?)](#ask) по ходу игры. Значения по-умолчанию
представлены в таблице ниже:

| Событие | Название | Очки |
|--------|--------|--------|
| Очки за открытый сундук | OPEN_TREASURE_BOX_SCORE | 1[(?)](#ask) |  
| Очки за уничтожение призрака | KILL_GHOST_SCORE | 10[(?)](#ask) |  
| Очки за уничтожение героя | KILL_OTHER_HERO_SCORE | 20[(?)](#ask) |  
| Очки за уничтожение вражеского героя | KILL_ENEMY_HERO_SCORE | 100[(?)](#ask) |  
| Очки за подобранный перк | CATCH_PERK_SCORE | 5[(?)](#ask) |  
| Штрафные очки за потерю своего героя | HERO_DIED_PENALTY | -30[(?)](#ask) |  
| Очки за победу в раунде | WIN_ROUND_SCORE | 30[(?)](#ask) |  
| Большой бадабум | BIG_BADABOOM | false[(?)](#ask) |  
| Количество зелья | POTIONS_COUNT | 1[(?)](#ask) |  
| Сила зелья | POTION_POWER | 3[(?)](#ask) |  
| Количество сундуков с сокровищами | TREASURE_BOX_COUNT | 52[(?)](#ask) |  
| Количество призраков | GHOSTS_COUNT | 5[(?)](#ask) |  
| Все товарищи по команде получают бонус за перк | PERK_WHOLE_TEAM_GET | false[(?)](#ask) |  
| Коэффициент выпадения перков в % | PERK_DROP_RATIO | 20[(?)](#ask) |  
| Таймаут перков | PERK_PICK_TIMEOUT | 30[(?)](#ask) |  
| Увеличение радиуса взрыва зелья | PERK_POTION_BLAST_RADIUS_INC | 2[(?)](#ask) |  
| Таймаут эффекта увеличения радиуса взрыва зелья | TIMEOUT_POTION_BLAST_RADIUS_INC | 30[(?)](#ask) |  
| Увеличение количества зелий | PERK_POTION_COUNT_INC | 4[(?)](#ask) |  
| Таймаут эффекта увеличение количества зелий | TIMEOUT_POTION_COUNT_INC | 30[(?)](#ask) |  
| Таймаут эффекта иммунитета к зельям | TIMEOUT_POTION_IMMUNE | 30[(?)](#ask) |  
| Таймаут эффекта метателя яда | TIMEOUT_POISON_THROWER | 30[(?)](#ask) |  
| Таймаут эффекта взрыва зелий | TIMEOUT_POTION_EXPLODER | 30[(?)](#ask) |  
| Перезарядка метателя яда | POISON_THROWER_RECHARGE | 3[(?)](#ask) |  
| Количество пультов управления Зельями (сколько раз игрок может их использовать) | REMOTE_CONTROL_COUNT | 3[(?)](#ask) |  
| Количество взрывателей зелий (сколько раз игрок может их использовать) | POTION_EXPLODER_COUNT | 1[(?)](#ask) |  
| Украсть очки у владельца зелья (работает с перком Potion Exploder) | STEAL_POINTS | false[(?)](#ask) |  
| Перки доступные в этой игре | DEFAULT_PERKS | ''[(?)](#ask) |  
| Режим подсчета очков | SCORE_COUNTING_TYPE | 0 (0 - Простой инкремент очков, 1 - Максимальное количество очков в комнате, 2 - Максимальное количество очков в серии между смертями героя)[(?)](#ask) |

## Кейзы

* Ты можешь комбинировать перки
* Кто получит очки после использования `POTION_EXPLODER` - решает Сенсей[(?)](#ask).
* Пожалуйста, будь уважителен с перками на поле.

## Подсказки

Первостепенная задача – написать websocket клиента, который подключится
к серверу. Затем заставить героя на поле слушаться команд.
Таким образом, игрок подготовится к основной игре.
Основная цель – вести осмысленную игру и победить.

Если ты не знаешь с чего начать, попробуй реализовать следующие алгоритмы:

* Перейти в случайную пустую соседнюю ячейку.
* Продвинуться вперед в свободную клетку в направлении ближайшего сундука.
* Попробуй взорвать что-то зельем.
* Попробуй спрятаться от взрывной волны.
* Попробуй избежать привидений и других героев.

## FAQ

* Интересно, что будет, если два игрока попытаются переместить своих героев 
  на одну клетку одновременно? Оба мага умрут?
  + Кто-то двинется первым, второй останется на прежнем месте.
* Что делать после клонирования клиента javascript?
  + Информацию о том, как начать играть, ты можешь найти в файле ReadMe.md.
    Тебе нужно обновить этот файл `browser-0-settings.js`.
    И после этого запустить файл `browser-2-run.html`. Логику бота стоит 
    реализовать в `codenjoy-javascript-client/games/mollymage/solver.js`. 
* What will I see on a client when dead ghost (created after destruction
  of a perk) meet treasure box on his way?
  + Destroyed perks just want to kill you. And he will try to get to you
    in the shortest way possible. If box appear on his way - he'll find
    another way to you.
* It seemed to me that they can destroy treasure boxes on their way
  + I see one thing in the server code, that if the treasure box appeared
    under the ghostHunter - he shows to us as opened treasure box
* Is there a way to get the information about what perks are active for
  the hero or should have to maintain this by ourselves?
  + Only maintain by yourself
* I am not able to find information about how long one perk is active;
  please share the link for the information in case I have missed this.
  + Sometimes it can changes. So here you can get server game settings
    [in json](/codenjoy-contest/rest/settings/player).
* So just wanted to double check - the finals - do we do rounds there? or
  the type of the game like indefinite free for all?
  + Final will be in Rounds with 7-9 heroes per room. The Heroes in the
    rooms will be constantly shuffling. There will be no fixed playgroups.
    Playing fields will also change from round to round.
* Now on map nothing moving - is it working now? Or still under maintenance?
  + Please check, maybe you in another game room. There are demo game flood
    room and event room. Please join in the event room.
* It would be good - if to have some sample code to have
  + Would be. Maybe some tips will help you. Please look into the classes
    which presented in your client. Class Board as usual has some methods
    that can help you analyze field state
* Fore some reason, flying GHOST_DEADs are shown as 'opening treasure boxes',
  is it an issue or I don't understand smth?
  + This is expected; blasting potions create flying ghosts which will find
    shortest path opening treasure to kill you.
* Is it possible for java client to load the local game in browser?
  + Java client could be loaded only from IDE or console. It does not have
    browser version. Only JS client has web version.
* I'm interested how the final would be conducted... Do we need to reconnect
  to the same server or other server? Or the score would be skipped and all
  connections would be saved?There is a risk that I could be absent at the
  moment, and would like to participate and look who's bot is the most
  successful. So I would like to plan my steps.
  + It will be in the same room. You need to play like you played before.
    The finale will begin with the room resetting points for all players. That's all.
* How to combine in JS both `ACT` and `LEFT`?
  + `return [Direction.ACT, Direction.LEFT];`

## <a id="ask"></a> Спроси Сенсея

Параметры могут изменяться по ходу игры. Настройки текущей игры
ты сможешь всегда [подглядеть тут](/codenjoy-contest/rest/settings/player).
Пожалуйста, спроси у Сенсея как интерпретировать эти данные. Ты можешь найти Сенсея
в чате, который подготовили организаторы для обсуждения вопросов.

## Клиент и API

Организаторы предоставляют игрокам подготовленные клиенты в исходном
коде на нескольких языках. Каждый из этих клиентов уже умеет связываться
с сервером, принимать и разбирать сообщение от сервера (обычно это называется board)
и отправлять серверу команды.

Слишком много форы клиентский код не дает играющим, поскольку в этом коде
еще надо разобраться, но там реализована логика общения с сервером +
некоторое высокоуровневое API для работы с доской (что уже приятно).

Все языки так или иначе имеют похожий набор методов:

* `Solver`
  Пустой класс с одним методом — ты должен(должна) наполнить его умной логикой.
* `Direcion`
  Возможные направления движения для этой игры.
* `Point`
  `x`, `y` координаты.
* `Element`
  Тип элемента на доске.
* `Board`
  Содержит логику для удобного поиска и манипуляции элементами на поле.
  Ты можешь найти следующие методы в Board классе:
* `int boardSize();` 
  Размер доски.
* `boolean isAt(Point point, Element element);` 
  Находится ли в позиции point заданный элемент?
* `boolean isAt(Point point, Collection<Element> elements);` 
  Находится ли в позиции point что-нибудь из заданного набора?
* `boolean isNear(Point point, Element element);` 
  Есть ли вокруг клеточки с координатой point заданный элемент?
* `int countNear(Point point, Element element);` 
  Сколько элементов заданного типа есть вокруг клетки с point?
* `Element getAt(Point point);` 
  Элемент в текущей клетке.
* `Point getHero();` 
  Позиция моего героя на доске.
* `boolean isGameOver();` 
  Жив ли мой герой?
* `Collection<Point> getOtherHeroes();` 
  Позиции всех остальных героев (из твоей команды) на доске.
* `Collection<Point> getEnemyHeroes();` 
  Позиции героев противника на доске.
* `Collection<Point> getBarriers();` 
  Позиции всех объектов препятствующих движению.
* `boolean isBarrierAt(Point point);`
  Есть ли препятствие в клеточке point? 
* `Collection<Point> getGhosts();` 
  Позиции всех призраков.
* `Collection<Point> getWalls();` 
  Позиции всех бетонных стен.
* `Collection<Point> getTreasureBoxes();` 
  Позиции всех сундуков с сокровищами (их можно открывать).
* `Collection<Point> getBombs();` 
  Позиции всех зелий.
* `Collection<Point> getFutureBlasts();` 
  Позиции потенциально опасных мест, где зелье может взорваться. 
  (зелье распространяется на N {решим перед началом игры} клеточек 
  в стороны: вверх, вниз, вправо, влево).
* и так далее... 

## Как провести такой же ивент самостоятельно?

Перед тобой opensource проект. Для реализации своей новой игры, модификации этой игры,
любой другой модификации сервера или исправления найденной ошибки
[форкни проект](https://github.com/codenjoyme/codenjoy.git).
Все инструкции ты найдешь в Readme.md файлах - они подскажут, что делать дальше.

Если у тебя есть вопросы - прошу, задавай их мне
в [скайпе alexander.baglay](skype:alexander.baglay)
или по почте [apofig@gmail.com](mailto:apofig@gmail.com).

Удачной игры и пусть победит сильнейший! 

